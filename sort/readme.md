# 排序

## 排序的概念

什么是排序 (Sorting)？简单地说，排序就是将一组杂乱无章的数据按一定的规律排列起来（递增或递减）。

关键字相同的记录在排序过程前后次序不变的排序称为稳定排序，否则称不稳定排序。



- **数据表** (Data List): 待排序的记录的有限集合;
- **关键字** (Key): 作为排序依据的各记录中的属性域;
- **排序** (Sorting): 使一组任意排列的数据表变成一组**按关键字线性有序**（递增或递减）的**数据表**.

## 排序的分类

**排序算法的稳定性**：关键字相同的记录在排序过程前后次序不变的排序称为稳定排序，否则称不稳定排序。

**内排序与外排序**：

- 内排序是指在排序过程中记录全部存放在内存的排序；
- 外排序是指在排序过程中数据量太大，不能同时存放在内存，在排序过程中不断进行内、外存之间数据交换的排序。

根据**数据表的存储方式**：

- **顺序存储方式**：通过移动记录的相对存储位置实现排序
- **链式存储方式**：通过修改各结点指针实现排序

## 排序算法分析

通常从**时间**和**空间**两个角度来考虑：

- 排序的时间效率:   通常用算法执行中的数据比较次数与数据移动次数来衡量；
- 排序的空间效率：通过算法执行时所需的附加存储空间多少来衡量。

### 插入排序

基本原理：将一个待排序的记录，按其关键字大小，插入到前面已经排好序的一组记录的适当位置上，直到记录全部插入为止。

#### 直接插入排序

基本思想：将第$i$个记录插入在前$i-1$个有序的记录中，使前$i$个记录有序。

主要操作步骤：

- `R[i]`暂存在`temp` 中；
- 将前`i-1`个有序区间中比其大的所有记录依次后移；
- 将`temp`中的值 (即`R[i]`) 插入。

#### 希尔排序

1959年由D.L. Shell提出, 又称缩小增量排序 (Diminishing-increment Sort).

基本思想：在排序中，每趟不断调整子序列的大小, 从而减少比较次数, 提高时间效率. 设计一个增量, 即序列$d_i(i=1,2,...)$, 其中$n>d_1>d_2>d_3...$ (通常$d_1=n/2,d_{i+1}=d_i/2$),每趟将数据表分成$d_i$组, 分别对各组进行直接插入排序, 直到最后全部记录在一组为止.



注: 希尔排序开始时增量大, 分组多, 各组含记录较少, 故各组插入快. 后来虽然增量逐渐减小, 各组含记录增多, 但各组已基本有序, 所以插入速度仍较快.

### 交换排序

基本原理：两两比较待排序记录的关键字, 若发生逆序 (即排列顺序与排序后的次序正好相反)，则交换之。直到所有记录都排好序为止。

#### 起泡排序

基本思想：在待排序子序列中，两两比较相邻记录的关键字，若逆序，则交换。

> 将子序列中最大记录沉到最后一个

当某趟没有发生交换时，就没有必要进行下一趟比较。

- 最好情况：初始时按关键字正序
- 最坏情况：初始时按关键字逆序

时间性能: $T(n)=O(n^2)$ 但在数据表基本有序的情况下效率比较高

空间性能: $S(n)=O(1)$ 排序在排序过程中，只需附加一个存储单元用于交换

稳定性: 稳定的排序 (关键字相同的记录不会交换次序)





#### 快速排序





## 章末简答

1. 什么是排序？什么是？
    简单地说，排序就是将一组杂乱无章的数据按一定的规律排列起来；
    
2. 内部排序与外部排序的主要区别是什么？
    内排序是指在排序过程中记录全部存放在内存的排序
    外排序是指在排序过程中数据量太大，不能同时存放在内存，在排序过程中不断进行内外存之间数据交换的排序
3. 连续顺序文件排序与链表排序的区别是什么？
    连续顺序文件排序：通过链表地址的前后映射，移动记录的位置。
    链表排序：文件中的一个记录对应链表中的一个链结点，指针反映逻辑顺序。
4. 如何进行直接插入排序？什么情况下效率最高？最少比较多少次？移动多少次？
    在插入第$i$个记录时，$R_1, R_2, ..., R_{i-1}$均已排好序，这时将$R_i$的关键字$K_i$依次与关键字$K_{i-1}, K_{i-2}$等进行比较，从而找到应该插入的位置并将Ri插入，插入位置及其后的记录依次向后移动。
    正序；比较$n-1$次；移动$2(n-1)$次；
5. 如何进行起泡排序？什么情况下效率最高？最少比较多少次？移动多少次？
    在待排序子序列中，两两比较相邻记录的关键字，若逆序，则交换
    正序；最少比较$n-1$次；移动0次；
6. 如何进行直接选择排序？其比较次数与初始状态有关吗？
    从待排序的元素中选出关键字最小的元素，顺序放在一排好的子表的最后，直到元素排序完毕。与初始状态无关。
7. 快速排序在什么情况下效率低？
    每次划分选取的基准都是当前无序区中关键字最小或最大的元素，即数据序列为正序或反序时。
8. 在8种排序中哪些排序方法能在第一趟就确定出最大（或最小）元素
    冒泡排序。



```cpp
#include <algorithm>

void CocktailSort(int *a, int nsize)
{
    int tail = nsize - 1;
    for (int i = 0; i < tail;)
    {
        for (int j = tail; j > i; --j) //第一轮，先将最小的数据排到前面
        {
            if (a[j] < a[j - 1]) std::swap(a[j], a[j-i]);
        }
        ++i; //原来i处数据已排好序，加1
        for (int j = i; j < tail; ++j) //第二轮，将最大的数据排到后面
        {
            if (a[j] > a[j + 1]) std::swap(a[j], a[j+i]);
        }
        tail--; //原tail处数据也已排好序，将其减1
    }
}
```



```cpp
#include <algorithm>

void Reverse(int *arr, int len)
{
    int i = 0, j = len - 1, temp;
    while (i < j)
    {
        while (i < j && arr[i] % 2 == 1) i++;
        while (i < j && arr[j] % 2 == 0) j--;
        if (i < j) std::swap(arr[i], arr[j]);
    }
}
```

