# 树

树是一种非线性的数据结构，用它能很好地描述有分支和层次特性的数据集合。

树型结构在现实世界中广泛存在，如社会组织机构的组织关系图就可以用树型结构来表示。

树在计算机领域中也有广泛应用，如在编译系统中，用树表示**源程序的语法结构**。在数据库系统中，树型结构是**数据库层次模型**的基础，也是各种索引和目录的主要组织形式。在许多算法中，常用树型结构描述问题的求解过程、所有解的状态和求解的对策等。在这些年的国内、国际信息学奥赛、大学生程序设计比赛等竞赛中，树型结构成为参赛者必备的知识之一，尤其是建立在树型结构基础之上的搜索算法。

在树型结构中，**二叉树**是最常用的结构，它的分支个数确定、又可以为空、并有良好的递归特性，特别适宜于程序设计，因此也常常将一般树转换成二叉树进行处理。

##  树的基本概念

### 树的定义

树的定义是**递归**的。

一颗树是由 n ( n >= 0 ) 个结点组成的有限集合。如果 n = 0，称为空树；如果 n > 0，则：
- 每个元素称为**结点** (node)；
- 有一个特定的结点，称之为**根结点**或树根(root)；
- 除根结点以外的其它结点划分为m (m >= 0) 个互不相交的有限集合![T_0,T_1,...,T_{m-1}](https://latex.codecogs.com/svg.latex?T_0,T_1,...,T_{m-1})，每个集合又是一棵树，并且称之为根的**子树**。

树的根结点没有前驱，其余的每个节点都有唯一的一个前驱结点。每个结点可以有0或多个后继结点。因此树虽然是**非线性结构**，但也是**有序**结构。前驱 / 后继结点的确定取决于树的遍历方法。

一个结点的子树的个数称为该结点的**度**(degree)。度为零的结点称为**叶子结点**（leaf）。度不为0的结点称为分支结点。根以外的分支结点又称为内部结点。树中所有结点的度的最大值为该树的度。

在用**图形表示的树型结构**中，对两个用线段连接的相关联的结点，称上端结点为下端结点的**父结点**，称下端结点为上端结点的**子结点**。称同一个父结点的多个子结点为**兄弟结点**。称从根结点到某个子结点所经过的所有结点为这个子结点的**祖先**。称以某个结点为根的子树中的任一结点为该结点的**子孙**。

定义一颗树的根结点**层次**（level）为1，其它结点的层次等于它的父结点层次加1。一棵树中所有的结点的层次的最大值为树的**深度** (depth)（或称为高度）。

**森林**（forest）是m (m >= 0) 棵互不相交的树的集合。

## 树的存储结构

3. 树有哪些存储方式？

   - 父亲表示法：即一个**数组**（线性表）。结点中包含`data`、`parent`两个元素，其中`parent`存储其父节点的位置。

     **优缺点**：该法利用树中除根节点外每个结点都有唯一的双亲结点/父节点的性质，可以很容易找到树根，但找孩子时需要遍历整个线性表。

   - 孩子表示法：即**树型单链表**结构。每个结点包括一个数据域和一个指针域（指向若干子节点）。

     **缺陷**：只能从根（父）结点遍历到子结点，不能从某个子结点返回到它的父结点。当确实需要从某个结点返回到它的父结点时，则需要在结点中多定义一个变量存放其父结点的信息。这种结构又叫**带逆序的树型结构**。

   - 父亲孩子表示法：即**树型双链表**结构。每个结点包括一个数据域和二个指针域（一个指向若干子结点，一个指向父结点）。

   - 孩子兄弟表示法：即**二叉树**型表示法。也是一种双链表结构，但每个结点包括一个数据域和二个指针域（一个指向该结点的第一个**孩子结点**，一个指向该结点的下一个**兄弟结点**）。


## 树的遍历

1. 树或森林的有哪些遍历方式

   - A：先序（根）遍历：先访问根结点，再从左到右按照先序思想遍历各棵子树。
   - B：后序（根）遍历：先从左到右遍历各棵子树，再访问根结点。
   - C：层次遍历：按层次从小到大逐个访问，同一层次按照从左到右的次序。

   可以看出，A、B两种方法的定义是递归的，所以在程序实现时往往也是采用递归的思想。也即通常所说的“深度优先搜索”。

   C方法应用也较多，实际上是我们讲的“广度优先搜索”。可以引入一个**队列**来存储等待访问的子结点：若某个结点被访问，则该结点的子结点应入队等待被访问。

## 二叉树

**二叉树**（binary tree，简写成BT）是一种特殊的树型结构。二叉树的度数<= 2，即二叉树的每个结点最多有两个子结点。每个结点的子结点分别称为**左孩子**、**右孩子**，它的两棵子树分别称为**左子树**、**右子树**。

二叉树有5中基本形态：

| 空二叉树   | 仅有根节点的二叉树 | 左子树为空的二叉树 | 右子树为空的二叉树 | 左、右子树均非空的二叉树 |
| ---------- | ------------------ | ------------------ | ------------------ | ------------------------ |
| *暂无图像* | *暂无图像*         | *暂无图像*         | *暂无图像*         | *暂无图像*               |



### 二叉树的性质

- 【性质1】二叉树的第![i](https://render.githubusercontent.com/render/math?math=i)层上最多有2<sup>i-1</sup>个结点

  > 证明：用归纳法：当 `i = 1` 时，2<sup>i-1</sup> = 1 显然成立；现在假设第 `i-1` 层时命题成立，即第 `i-1` 层上最多有 2<sup>i-2</sup> 个结点。由于二叉树的每个结点的度最多为2，故在第`i`层上的最大结点数为第`i-1`层的2倍，即![2*2^{i-2}=2^{i-1}](https://latex.codecogs.com/svg.latex?2*2^{i-2}=2^{i-1})。

- 【性质2】深度为![k](https://render.githubusercontent.com/render/math?math=k)的二叉树至多有2<sup>k –1</sup>个结点

  > 证明：在具有相同深度的二叉树中，仅当每一层都含有最大结点数时，其树中结点数最多。因此利用性质1可得，深度为 *k* 的二叉树的结点数至多为：![2^0+2^1+...+2^{k-1}=2^k-1](https://latex.codecogs.com/svg.latex?2^0+2^1+...+2^{k-1}=2^k-1)。

  特别的，一棵深度为![k](https://render.githubusercontent.com/render/math?math=k)且有![2^k-1](https://latex.codecogs.com/svg.latex?2^k-1)个结点的二叉树称为**满二叉树**，这种树的特点是每层上的结点数都是最大结点数。

- 【性质3】对任意一棵二叉树，如果其叶结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则一定满足：![n_0=n_2+1](https://latex.codecogs.com/svg.latex?n_0=n_2+1)。

  > 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数（记为n）应等于0度结点数n<sub>0</sub>、1度结点n<sub>1</sub>和2度结点数n<sub>2</sub>之和：n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub> （式子1）
  >
  > 另一方面，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n<sub>1</sub> + 2n<sub>2</sub> 
  >
  > 树中只有根结点不是任何结点的孩子，故二叉树中的结点总数又可表示为：n = n<sub>1</sub> + 2n<sub>2</sub> + 1 （式子2）
  >
  > 由式子1和式子2得到 n<sub>0</sub> = n<sub>2 </sub>+1.

- 【性质4】具有n (n >= 0) 个结点的完全二叉树的深度为![floor(log_2(n))+1](https://latex.codecogs.com/svg.latex?\lfloor{log_2(n)}\rfloor%2B1)（或者![ceil(log_2(n+1))-1](https://latex.codecogs.com/svg.latex?\lceil{log_2(n+1)}\rceil-1)）

  > 证明：假设深度为k，则根据完全二叉树的定义，前面k-1层一定是满的，所以2<sup>(k – 1) - 1</sup>。但n又要满足n <= 2<sup>k –1</sup>。所以，2<sup>(k – 1) - 1</sup>< n <= 2<sup>k –1</sup>。变换一下为 2<sup>k –1</sup> <= n <  2<sup>k</sup>。
  >
  > 以2为底取对数得到![k-1<=log_2(n)<k](https://latex.codecogs.com/svg.latex?k-1\leqslant%20log_2(n)<k)。而k是整数，所以  ![k=floor(log_2(n))+1](https://latex.codecogs.com/svg.latex?k=\lfloor{log_2(n)}\rfloor%2B1)。

- 【性质5】对于一棵n个结点的完全二叉树，对任一个编号为 i 的结点：
  - 如果 i = 1，则结点 i 为根，无父结点；
    如果 i > 1，则其父结点编号为 i / 2。
  - 若2 * i <= n, 则结点 i 的左孩子编号为 2 \* i；否则结点 i 无左孩子（当然也无右孩子，即结点 i 为叶结点）
  - 若2 \* i + 1 <= n，则其右孩子编号为2 \* i + 1；否则结点 i 无右孩子。

满二叉树的特点是什么？完全二叉树的特点是什么？

**满二叉树**：

- 深度为![k](https://render.githubusercontent.com/render/math?math=k)且有2<sup>k –1</sup>个结点；
- 所有分支结点的度为 2，n<sub>1</sub> = 0；
- 叶子结点都在最下一层。

**完全二叉树**：

- 叶子结点都在最下两层，且最下一层集中在最左边。

完全二叉树


若一完全二叉树共有240个结点，则其有<u>  120  </u>个叶子节点。

```
1    = 1 
3    = 1 + 2
7    = 1 + 2 + 4 
15   = 1 + 2 + 4 + 8 
31   = 1 + 2 + 4 + 8 + 16 
63   = 1 + 2 + 4 + 8 + 16 + 32 
127  = 1 + 2 + 4 + 8 + 16 + 32 + 64 
255  = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 
511  = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256 
...
```


二叉树按顺序方式存储和链式方式存储的表示。

**顺序存储方式**：

由于（性质5）完全二叉树按层次编号后，可确定各结点与其双亲及孩子的关系，则完全二叉树按编号次序进行顺序表示。

将一般二叉树转换为完全二叉树（添加虚结点），然后按层次编号次序进行顺序表示。

**链式存储方式**：

即单链表结构或双链表结构（同树）。

二叉链表：

- `lchild`：指向左孩子结点、

- `rchild`：指向右孩子结点
- `data`：存储数据

三叉链表：增加一个`parent`变量指向父节点。

二叉树有哪些遍历方式？

在二叉树的应用中，常常要求在树中查找具有某种特征的结点，或者对全部结点逐一进行某种处理。这就是二叉树的遍历问题。

所谓二叉树的遍历是指按一定的规律和次序访问树中的各个结点，而且每个结点仅被**访问**一次。

**访问**的含义很广，可以是对结点作各种处理，如输出结点的信息等。

遍历一般按照从左到右的顺序，共有3种遍历方法，先（根）序遍历，中（根）序遍历，后（根）序遍历。

| 先序遍历             | 中序遍历           | 后序遍历           |
| -------------------- | ------------------ | ------------------ |
| 若二叉树非空，则：<br>- 访问根结点<br>- **先序遍历**左子树<br>- **先序遍历**右子树 | 若二叉树非空，则：<br>- **中序遍历**左子树<br>- 访问根结点<br>- **中序遍历**右子树 | 若二叉树非空，则：<br>- **后序遍历**左子树<br>- **后序遍历**右子树<br>- 访问根节点 |

1. 给定二叉树如何转换为树或树林，给定树或树林如何转换为二叉树。



---



1. N个结点的线索二叉树按二叉链表方式存，共有多少指针域？其中多少指针域为线索。
2. m个叶子结点的哈夫曼树共有多少各个结点？



## 树的应用

### 哈夫曼树

哈夫曼编码



最佳判定树



